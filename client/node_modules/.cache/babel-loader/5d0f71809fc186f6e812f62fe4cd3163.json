{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformWebkitRadialGradientArgs = exports.parseGradient = exports.RadialGradient = exports.LinearGradient = exports.RADIAL_GRADIENT_SHAPE = exports.GRADIENT_TYPE = undefined;\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nvar _NodeContainer = require('./NodeContainer');\nvar _NodeContainer2 = _interopRequireDefault(_NodeContainer);\nvar _Angle = require('./Angle');\nvar _Color = require('./Color');\nvar _Color2 = _interopRequireDefault(_Color);\nvar _Length = require('./Length');\nvar _Length2 = _interopRequireDefault(_Length);\nvar _Util = require('./Util');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar SIDE_OR_CORNER = /^(to )?(left|top|right|bottom)( (left|top|right|bottom))?$/i;\nvar PERCENTAGE_ANGLES = /^([+-]?\\d*\\.?\\d+)% ([+-]?\\d*\\.?\\d+)%$/i;\nvar ENDS_WITH_LENGTH = /(px)|%|( 0)$/i;\nvar FROM_TO_COLORSTOP = /^(from|to|color-stop)\\((?:([\\d.]+)(%)?,\\s*)?(.+?)\\)$/i;\nvar RADIAL_SHAPE_DEFINITION = /^\\s*(circle|ellipse)?\\s*((?:([\\d.]+)(px|r?em|%)\\s*(?:([\\d.]+)(px|r?em|%))?)|closest-side|closest-corner|farthest-side|farthest-corner)?\\s*(?:at\\s*(?:(left|center|right)|([\\d.]+)(px|r?em|%))\\s+(?:(top|center|bottom)|([\\d.]+)(px|r?em|%)))?(?:\\s|$)/i;\nvar GRADIENT_TYPE = exports.GRADIENT_TYPE = {\n  LINEAR_GRADIENT: 0,\n  RADIAL_GRADIENT: 1\n};\nvar RADIAL_GRADIENT_SHAPE = exports.RADIAL_GRADIENT_SHAPE = {\n  CIRCLE: 0,\n  ELLIPSE: 1\n};\nvar LENGTH_FOR_POSITION = {\n  left: new _Length2.default('0%'),\n  top: new _Length2.default('0%'),\n  center: new _Length2.default('50%'),\n  right: new _Length2.default('100%'),\n  bottom: new _Length2.default('100%')\n};\nvar LinearGradient = exports.LinearGradient = function LinearGradient(colorStops, direction) {\n  _classCallCheck(this, LinearGradient);\n  this.type = GRADIENT_TYPE.LINEAR_GRADIENT;\n  this.colorStops = colorStops;\n  this.direction = direction;\n};\nvar RadialGradient = exports.RadialGradient = function RadialGradient(colorStops, shape, center, radius) {\n  _classCallCheck(this, RadialGradient);\n  this.type = GRADIENT_TYPE.RADIAL_GRADIENT;\n  this.colorStops = colorStops;\n  this.shape = shape;\n  this.center = center;\n  this.radius = radius;\n};\nvar parseGradient = exports.parseGradient = function parseGradient(container, _ref, bounds) {\n  var args = _ref.args,\n    method = _ref.method,\n    prefix = _ref.prefix;\n  if (method === 'linear-gradient') {\n    return parseLinearGradient(args, bounds, !!prefix);\n  } else if (method === 'gradient' && args[0] === 'linear') {\n    // TODO handle correct angle\n    return parseLinearGradient(['to bottom'].concat(transformObsoleteColorStops(args.slice(3))), bounds, !!prefix);\n  } else if (method === 'radial-gradient') {\n    return parseRadialGradient(container, prefix === '-webkit-' ? transformWebkitRadialGradientArgs(args) : args, bounds);\n  } else if (method === 'gradient' && args[0] === 'radial') {\n    return parseRadialGradient(container, transformObsoleteColorStops(transformWebkitRadialGradientArgs(args.slice(1))), bounds);\n  }\n};\nvar parseColorStops = function parseColorStops(args, firstColorStopIndex, lineLength) {\n  var colorStops = [];\n  for (var i = firstColorStopIndex; i < args.length; i++) {\n    var value = args[i];\n    var HAS_LENGTH = ENDS_WITH_LENGTH.test(value);\n    var lastSpaceIndex = value.lastIndexOf(' ');\n    var _color = new _Color2.default(HAS_LENGTH ? value.substring(0, lastSpaceIndex) : value);\n    var _stop = HAS_LENGTH ? new _Length2.default(value.substring(lastSpaceIndex + 1)) : i === firstColorStopIndex ? new _Length2.default('0%') : i === args.length - 1 ? new _Length2.default('100%') : null;\n    colorStops.push({\n      color: _color,\n      stop: _stop\n    });\n  }\n  var absoluteValuedColorStops = colorStops.map(function (_ref2) {\n    var color = _ref2.color,\n      stop = _ref2.stop;\n    var absoluteStop = lineLength === 0 ? 0 : stop ? stop.getAbsoluteValue(lineLength) / lineLength : null;\n    return {\n      color: color,\n      // $FlowFixMe\n      stop: absoluteStop\n    };\n  });\n  var previousColorStop = absoluteValuedColorStops[0].stop;\n  for (var _i = 0; _i < absoluteValuedColorStops.length; _i++) {\n    if (previousColorStop !== null) {\n      var _stop2 = absoluteValuedColorStops[_i].stop;\n      if (_stop2 === null) {\n        var n = _i;\n        while (absoluteValuedColorStops[n].stop === null) {\n          n++;\n        }\n        var steps = n - _i + 1;\n        var nextColorStep = absoluteValuedColorStops[n].stop;\n        var stepSize = (nextColorStep - previousColorStop) / steps;\n        for (; _i < n; _i++) {\n          previousColorStop = absoluteValuedColorStops[_i].stop = previousColorStop + stepSize;\n        }\n      } else {\n        previousColorStop = _stop2;\n      }\n    }\n  }\n  return absoluteValuedColorStops;\n};\nvar parseLinearGradient = function parseLinearGradient(args, bounds, hasPrefix) {\n  var angle = (0, _Angle.parseAngle)(args[0]);\n  var HAS_SIDE_OR_CORNER = SIDE_OR_CORNER.test(args[0]);\n  var HAS_DIRECTION = HAS_SIDE_OR_CORNER || angle !== null || PERCENTAGE_ANGLES.test(args[0]);\n  var direction = HAS_DIRECTION ? angle !== null ? calculateGradientDirection(\n  // if there is a prefix, the 0Â° angle points due East (instead of North per W3C)\n  hasPrefix ? angle - Math.PI * 0.5 : angle, bounds) : HAS_SIDE_OR_CORNER ? parseSideOrCorner(args[0], bounds) : parsePercentageAngle(args[0], bounds) : calculateGradientDirection(Math.PI, bounds);\n  var firstColorStopIndex = HAS_DIRECTION ? 1 : 0;\n\n  // TODO: Fix some inaccuracy with color stops with px values\n  var lineLength = Math.min((0, _Util.distance)(Math.abs(direction.x0) + Math.abs(direction.x1), Math.abs(direction.y0) + Math.abs(direction.y1)), bounds.width * 2, bounds.height * 2);\n  return new LinearGradient(parseColorStops(args, firstColorStopIndex, lineLength), direction);\n};\nvar parseRadialGradient = function parseRadialGradient(container, args, bounds) {\n  var m = args[0].match(RADIAL_SHAPE_DEFINITION);\n  var shape = m && (m[1] === 'circle' ||\n  // explicit shape specification\n  m[3] !== undefined && m[5] === undefined) // only one radius coordinate\n  ? RADIAL_GRADIENT_SHAPE.CIRCLE : RADIAL_GRADIENT_SHAPE.ELLIPSE;\n  var radius = {};\n  var center = {};\n  if (m) {\n    // Radius\n    if (m[3] !== undefined) {\n      radius.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[3], m[4]).getAbsoluteValue(bounds.width);\n    }\n    if (m[5] !== undefined) {\n      radius.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[5], m[6]).getAbsoluteValue(bounds.height);\n    }\n\n    // Position\n    if (m[7]) {\n      center.x = LENGTH_FOR_POSITION[m[7].toLowerCase()];\n    } else if (m[8] !== undefined) {\n      center.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[8], m[9]);\n    }\n    if (m[10]) {\n      center.y = LENGTH_FOR_POSITION[m[10].toLowerCase()];\n    } else if (m[11] !== undefined) {\n      center.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[11], m[12]);\n    }\n  }\n  var gradientCenter = {\n    x: center.x === undefined ? bounds.width / 2 : center.x.getAbsoluteValue(bounds.width),\n    y: center.y === undefined ? bounds.height / 2 : center.y.getAbsoluteValue(bounds.height)\n  };\n  var gradientRadius = calculateRadius(m && m[2] || 'farthest-corner', shape, gradientCenter, radius, bounds);\n  return new RadialGradient(parseColorStops(args, m ? 1 : 0, Math.min(gradientRadius.x, gradientRadius.y)), shape, gradientCenter, gradientRadius);\n};\nvar calculateGradientDirection = function calculateGradientDirection(radian, bounds) {\n  var width = bounds.width;\n  var height = bounds.height;\n  var HALF_WIDTH = width * 0.5;\n  var HALF_HEIGHT = height * 0.5;\n  var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));\n  var HALF_LINE_LENGTH = lineLength / 2;\n  var x0 = HALF_WIDTH + Math.sin(radian) * HALF_LINE_LENGTH;\n  var y0 = HALF_HEIGHT - Math.cos(radian) * HALF_LINE_LENGTH;\n  var x1 = width - x0;\n  var y1 = height - y0;\n  return {\n    x0: x0,\n    x1: x1,\n    y0: y0,\n    y1: y1\n  };\n};\nvar parseTopRight = function parseTopRight(bounds) {\n  return Math.acos(bounds.width / 2 / ((0, _Util.distance)(bounds.width, bounds.height) / 2));\n};\nvar parseSideOrCorner = function parseSideOrCorner(side, bounds) {\n  switch (side) {\n    case 'bottom':\n    case 'to top':\n      return calculateGradientDirection(0, bounds);\n    case 'left':\n    case 'to right':\n      return calculateGradientDirection(Math.PI / 2, bounds);\n    case 'right':\n    case 'to left':\n      return calculateGradientDirection(3 * Math.PI / 2, bounds);\n    case 'top right':\n    case 'right top':\n    case 'to bottom left':\n    case 'to left bottom':\n      return calculateGradientDirection(Math.PI + parseTopRight(bounds), bounds);\n    case 'top left':\n    case 'left top':\n    case 'to bottom right':\n    case 'to right bottom':\n      return calculateGradientDirection(Math.PI - parseTopRight(bounds), bounds);\n    case 'bottom left':\n    case 'left bottom':\n    case 'to top right':\n    case 'to right top':\n      return calculateGradientDirection(parseTopRight(bounds), bounds);\n    case 'bottom right':\n    case 'right bottom':\n    case 'to top left':\n    case 'to left top':\n      return calculateGradientDirection(2 * Math.PI - parseTopRight(bounds), bounds);\n    case 'top':\n    case 'to bottom':\n    default:\n      return calculateGradientDirection(Math.PI, bounds);\n  }\n};\nvar parsePercentageAngle = function parsePercentageAngle(angle, bounds) {\n  var _angle$split$map = angle.split(' ').map(parseFloat),\n    _angle$split$map2 = _slicedToArray(_angle$split$map, 2),\n    left = _angle$split$map2[0],\n    top = _angle$split$map2[1];\n  var ratio = left / 100 * bounds.width / (top / 100 * bounds.height);\n  return calculateGradientDirection(Math.atan(isNaN(ratio) ? 1 : ratio) + Math.PI / 2, bounds);\n};\nvar findCorner = function findCorner(bounds, x, y, closest) {\n  var corners = [{\n    x: 0,\n    y: 0\n  }, {\n    x: 0,\n    y: bounds.height\n  }, {\n    x: bounds.width,\n    y: 0\n  }, {\n    x: bounds.width,\n    y: bounds.height\n  }];\n\n  // $FlowFixMe\n  return corners.reduce(function (stat, corner) {\n    var d = (0, _Util.distance)(x - corner.x, y - corner.y);\n    if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {\n      return {\n        optimumCorner: corner,\n        optimumDistance: d\n      };\n    }\n    return stat;\n  }, {\n    optimumDistance: closest ? Infinity : -Infinity,\n    optimumCorner: null\n  }).optimumCorner;\n};\nvar calculateRadius = function calculateRadius(extent, shape, center, radius, bounds) {\n  var x = center.x;\n  var y = center.y;\n  var rx = 0;\n  var ry = 0;\n  switch (extent) {\n    case 'closest-side':\n      // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradientâs center.\n      // If the shape is an ellipse, it exactly meets the closest side in each dimension.\n      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n        rx = ry = Math.min(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));\n      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n        rx = Math.min(Math.abs(x), Math.abs(x - bounds.width));\n        ry = Math.min(Math.abs(y), Math.abs(y - bounds.height));\n      }\n      break;\n    case 'closest-corner':\n      // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradientâs center.\n      // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.\n      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n        rx = ry = Math.min((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));\n      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n        // Compute the ratio ry/rx (which is to be the same as for \"closest-side\")\n        var c = Math.min(Math.abs(y), Math.abs(y - bounds.height)) / Math.min(Math.abs(x), Math.abs(x - bounds.width));\n        var corner = findCorner(bounds, x, y, true);\n        rx = (0, _Util.distance)(corner.x - x, (corner.y - y) / c);\n        ry = c * rx;\n      }\n      break;\n    case 'farthest-side':\n      // Same as closest-side, except the ending shape is sized based on the farthest side(s)\n      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n        rx = ry = Math.max(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));\n      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n        rx = Math.max(Math.abs(x), Math.abs(x - bounds.width));\n        ry = Math.max(Math.abs(y), Math.abs(y - bounds.height));\n      }\n      break;\n    case 'farthest-corner':\n      // Same as closest-corner, except the ending shape is sized based on the farthest corner.\n      // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.\n      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n        rx = ry = Math.max((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));\n      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n        // Compute the ratio ry/rx (which is to be the same as for \"farthest-side\")\n        var _c = Math.max(Math.abs(y), Math.abs(y - bounds.height)) / Math.max(Math.abs(x), Math.abs(x - bounds.width));\n        var _corner = findCorner(bounds, x, y, false);\n        rx = (0, _Util.distance)(_corner.x - x, (_corner.y - y) / _c);\n        ry = _c * rx;\n      }\n      break;\n    default:\n      // pixel or percentage values\n      rx = radius.x || 0;\n      ry = radius.y !== undefined ? radius.y : rx;\n      break;\n  }\n  return {\n    x: rx,\n    y: ry\n  };\n};\nvar transformWebkitRadialGradientArgs = exports.transformWebkitRadialGradientArgs = function transformWebkitRadialGradientArgs(args) {\n  var shape = '';\n  var radius = '';\n  var extent = '';\n  var position = '';\n  var idx = 0;\n  var POSITION = /^(left|center|right|\\d+(?:px|r?em|%)?)(?:\\s+(top|center|bottom|\\d+(?:px|r?em|%)?))?$/i;\n  var SHAPE_AND_EXTENT = /^(circle|ellipse)?\\s*(closest-side|closest-corner|farthest-side|farthest-corner|contain|cover)?$/i;\n  var RADIUS = /^\\d+(px|r?em|%)?(?:\\s+\\d+(px|r?em|%)?)?$/i;\n  var matchStartPosition = args[idx].match(POSITION);\n  if (matchStartPosition) {\n    idx++;\n  }\n  var matchShapeExtent = args[idx].match(SHAPE_AND_EXTENT);\n  if (matchShapeExtent) {\n    shape = matchShapeExtent[1] || '';\n    extent = matchShapeExtent[2] || '';\n    if (extent === 'contain') {\n      extent = 'closest-side';\n    } else if (extent === 'cover') {\n      extent = 'farthest-corner';\n    }\n    idx++;\n  }\n  var matchStartRadius = args[idx].match(RADIUS);\n  if (matchStartRadius) {\n    idx++;\n  }\n  var matchEndPosition = args[idx].match(POSITION);\n  if (matchEndPosition) {\n    idx++;\n  }\n  var matchEndRadius = args[idx].match(RADIUS);\n  if (matchEndRadius) {\n    idx++;\n  }\n  var matchPosition = matchEndPosition || matchStartPosition;\n  if (matchPosition && matchPosition[1]) {\n    position = matchPosition[1] + (/^\\d+$/.test(matchPosition[1]) ? 'px' : '');\n    if (matchPosition[2]) {\n      position += ' ' + matchPosition[2] + (/^\\d+$/.test(matchPosition[2]) ? 'px' : '');\n    }\n  }\n  var matchRadius = matchEndRadius || matchStartRadius;\n  if (matchRadius) {\n    radius = matchRadius[0];\n    if (!matchRadius[1]) {\n      radius += 'px';\n    }\n  }\n  if (position && !shape && !radius && !extent) {\n    radius = position;\n    position = '';\n  }\n  if (position) {\n    position = 'at ' + position;\n  }\n  return [[shape, extent, radius, position].filter(function (s) {\n    return !!s;\n  }).join(' ')].concat(args.slice(idx));\n};\nvar transformObsoleteColorStops = function transformObsoleteColorStops(args) {\n  return args.map(function (color) {\n    return color.match(FROM_TO_COLORSTOP);\n  })\n  // $FlowFixMe\n  .map(function (v, index) {\n    if (!v) {\n      return args[index];\n    }\n    switch (v[1]) {\n      case 'from':\n        return v[4] + ' 0%';\n      case 'to':\n        return v[4] + ' 100%';\n      case 'color-stop':\n        if (v[3] === '%') {\n          return v[4] + ' ' + v[2];\n        }\n        return v[4] + ' ' + parseFloat(v[2]) * 100 + '%';\n    }\n  });\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","transformWebkitRadialGradientArgs","parseGradient","RadialGradient","LinearGradient","RADIAL_GRADIENT_SHAPE","GRADIENT_TYPE","undefined","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","_NodeContainer","require","_NodeContainer2","_interopRequireDefault","_Angle","_Color","_Color2","_Length","_Length2","_Util","obj","__esModule","default","_classCallCheck","instance","Constructor","SIDE_OR_CORNER","PERCENTAGE_ANGLES","ENDS_WITH_LENGTH","FROM_TO_COLORSTOP","RADIAL_SHAPE_DEFINITION","LINEAR_GRADIENT","RADIAL_GRADIENT","CIRCLE","ELLIPSE","LENGTH_FOR_POSITION","left","top","center","right","bottom","colorStops","direction","type","shape","radius","container","_ref","bounds","args","method","prefix","parseLinearGradient","concat","transformObsoleteColorStops","slice","parseRadialGradient","parseColorStops","firstColorStopIndex","lineLength","HAS_LENGTH","test","lastSpaceIndex","lastIndexOf","_color","substring","_stop","color","stop","absoluteValuedColorStops","map","_ref2","absoluteStop","getAbsoluteValue","previousColorStop","_stop2","n","steps","nextColorStep","stepSize","hasPrefix","angle","parseAngle","HAS_SIDE_OR_CORNER","HAS_DIRECTION","calculateGradientDirection","Math","PI","parseSideOrCorner","parsePercentageAngle","min","distance","abs","x0","x1","y0","y1","width","height","m","match","x","calculateLengthFromValueWithUnit","y","toLowerCase","gradientCenter","gradientRadius","calculateRadius","radian","HALF_WIDTH","HALF_HEIGHT","sin","cos","HALF_LINE_LENGTH","parseTopRight","acos","side","_angle$split$map","split","parseFloat","_angle$split$map2","ratio","atan","isNaN","findCorner","closest","corners","reduce","stat","corner","d","optimumDistance","optimumCorner","Infinity","extent","rx","ry","c","max","_c","_corner","position","idx","POSITION","SHAPE_AND_EXTENT","RADIUS","matchStartPosition","matchShapeExtent","matchStartRadius","matchEndPosition","matchEndRadius","matchPosition","matchRadius","filter","s","join","v","index"],"sources":["C:/newLpmss/webProtech_lms/client/node_modules/html2canvas/dist/npm/Gradient.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.transformWebkitRadialGradientArgs = exports.parseGradient = exports.RadialGradient = exports.LinearGradient = exports.RADIAL_GRADIENT_SHAPE = exports.GRADIENT_TYPE = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _NodeContainer = require('./NodeContainer');\n\nvar _NodeContainer2 = _interopRequireDefault(_NodeContainer);\n\nvar _Angle = require('./Angle');\n\nvar _Color = require('./Color');\n\nvar _Color2 = _interopRequireDefault(_Color);\n\nvar _Length = require('./Length');\n\nvar _Length2 = _interopRequireDefault(_Length);\n\nvar _Util = require('./Util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SIDE_OR_CORNER = /^(to )?(left|top|right|bottom)( (left|top|right|bottom))?$/i;\nvar PERCENTAGE_ANGLES = /^([+-]?\\d*\\.?\\d+)% ([+-]?\\d*\\.?\\d+)%$/i;\nvar ENDS_WITH_LENGTH = /(px)|%|( 0)$/i;\nvar FROM_TO_COLORSTOP = /^(from|to|color-stop)\\((?:([\\d.]+)(%)?,\\s*)?(.+?)\\)$/i;\nvar RADIAL_SHAPE_DEFINITION = /^\\s*(circle|ellipse)?\\s*((?:([\\d.]+)(px|r?em|%)\\s*(?:([\\d.]+)(px|r?em|%))?)|closest-side|closest-corner|farthest-side|farthest-corner)?\\s*(?:at\\s*(?:(left|center|right)|([\\d.]+)(px|r?em|%))\\s+(?:(top|center|bottom)|([\\d.]+)(px|r?em|%)))?(?:\\s|$)/i;\n\nvar GRADIENT_TYPE = exports.GRADIENT_TYPE = {\n    LINEAR_GRADIENT: 0,\n    RADIAL_GRADIENT: 1\n};\n\nvar RADIAL_GRADIENT_SHAPE = exports.RADIAL_GRADIENT_SHAPE = {\n    CIRCLE: 0,\n    ELLIPSE: 1\n};\n\nvar LENGTH_FOR_POSITION = {\n    left: new _Length2.default('0%'),\n    top: new _Length2.default('0%'),\n    center: new _Length2.default('50%'),\n    right: new _Length2.default('100%'),\n    bottom: new _Length2.default('100%')\n};\n\nvar LinearGradient = exports.LinearGradient = function LinearGradient(colorStops, direction) {\n    _classCallCheck(this, LinearGradient);\n\n    this.type = GRADIENT_TYPE.LINEAR_GRADIENT;\n    this.colorStops = colorStops;\n    this.direction = direction;\n};\n\nvar RadialGradient = exports.RadialGradient = function RadialGradient(colorStops, shape, center, radius) {\n    _classCallCheck(this, RadialGradient);\n\n    this.type = GRADIENT_TYPE.RADIAL_GRADIENT;\n    this.colorStops = colorStops;\n    this.shape = shape;\n    this.center = center;\n    this.radius = radius;\n};\n\nvar parseGradient = exports.parseGradient = function parseGradient(container, _ref, bounds) {\n    var args = _ref.args,\n        method = _ref.method,\n        prefix = _ref.prefix;\n\n    if (method === 'linear-gradient') {\n        return parseLinearGradient(args, bounds, !!prefix);\n    } else if (method === 'gradient' && args[0] === 'linear') {\n        // TODO handle correct angle\n        return parseLinearGradient(['to bottom'].concat(transformObsoleteColorStops(args.slice(3))), bounds, !!prefix);\n    } else if (method === 'radial-gradient') {\n        return parseRadialGradient(container, prefix === '-webkit-' ? transformWebkitRadialGradientArgs(args) : args, bounds);\n    } else if (method === 'gradient' && args[0] === 'radial') {\n        return parseRadialGradient(container, transformObsoleteColorStops(transformWebkitRadialGradientArgs(args.slice(1))), bounds);\n    }\n};\n\nvar parseColorStops = function parseColorStops(args, firstColorStopIndex, lineLength) {\n    var colorStops = [];\n\n    for (var i = firstColorStopIndex; i < args.length; i++) {\n        var value = args[i];\n        var HAS_LENGTH = ENDS_WITH_LENGTH.test(value);\n        var lastSpaceIndex = value.lastIndexOf(' ');\n        var _color = new _Color2.default(HAS_LENGTH ? value.substring(0, lastSpaceIndex) : value);\n        var _stop = HAS_LENGTH ? new _Length2.default(value.substring(lastSpaceIndex + 1)) : i === firstColorStopIndex ? new _Length2.default('0%') : i === args.length - 1 ? new _Length2.default('100%') : null;\n        colorStops.push({ color: _color, stop: _stop });\n    }\n\n    var absoluteValuedColorStops = colorStops.map(function (_ref2) {\n        var color = _ref2.color,\n            stop = _ref2.stop;\n\n        var absoluteStop = lineLength === 0 ? 0 : stop ? stop.getAbsoluteValue(lineLength) / lineLength : null;\n\n        return {\n            color: color,\n            // $FlowFixMe\n            stop: absoluteStop\n        };\n    });\n\n    var previousColorStop = absoluteValuedColorStops[0].stop;\n    for (var _i = 0; _i < absoluteValuedColorStops.length; _i++) {\n        if (previousColorStop !== null) {\n            var _stop2 = absoluteValuedColorStops[_i].stop;\n            if (_stop2 === null) {\n                var n = _i;\n                while (absoluteValuedColorStops[n].stop === null) {\n                    n++;\n                }\n                var steps = n - _i + 1;\n                var nextColorStep = absoluteValuedColorStops[n].stop;\n                var stepSize = (nextColorStep - previousColorStop) / steps;\n                for (; _i < n; _i++) {\n                    previousColorStop = absoluteValuedColorStops[_i].stop = previousColorStop + stepSize;\n                }\n            } else {\n                previousColorStop = _stop2;\n            }\n        }\n    }\n\n    return absoluteValuedColorStops;\n};\n\nvar parseLinearGradient = function parseLinearGradient(args, bounds, hasPrefix) {\n    var angle = (0, _Angle.parseAngle)(args[0]);\n    var HAS_SIDE_OR_CORNER = SIDE_OR_CORNER.test(args[0]);\n    var HAS_DIRECTION = HAS_SIDE_OR_CORNER || angle !== null || PERCENTAGE_ANGLES.test(args[0]);\n    var direction = HAS_DIRECTION ? angle !== null ? calculateGradientDirection(\n    // if there is a prefix, the 0Â° angle points due East (instead of North per W3C)\n    hasPrefix ? angle - Math.PI * 0.5 : angle, bounds) : HAS_SIDE_OR_CORNER ? parseSideOrCorner(args[0], bounds) : parsePercentageAngle(args[0], bounds) : calculateGradientDirection(Math.PI, bounds);\n    var firstColorStopIndex = HAS_DIRECTION ? 1 : 0;\n\n    // TODO: Fix some inaccuracy with color stops with px values\n    var lineLength = Math.min((0, _Util.distance)(Math.abs(direction.x0) + Math.abs(direction.x1), Math.abs(direction.y0) + Math.abs(direction.y1)), bounds.width * 2, bounds.height * 2);\n\n    return new LinearGradient(parseColorStops(args, firstColorStopIndex, lineLength), direction);\n};\n\nvar parseRadialGradient = function parseRadialGradient(container, args, bounds) {\n    var m = args[0].match(RADIAL_SHAPE_DEFINITION);\n    var shape = m && (m[1] === 'circle' || // explicit shape specification\n    m[3] !== undefined && m[5] === undefined) // only one radius coordinate\n    ? RADIAL_GRADIENT_SHAPE.CIRCLE : RADIAL_GRADIENT_SHAPE.ELLIPSE;\n    var radius = {};\n    var center = {};\n\n    if (m) {\n        // Radius\n        if (m[3] !== undefined) {\n            radius.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[3], m[4]).getAbsoluteValue(bounds.width);\n        }\n\n        if (m[5] !== undefined) {\n            radius.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[5], m[6]).getAbsoluteValue(bounds.height);\n        }\n\n        // Position\n        if (m[7]) {\n            center.x = LENGTH_FOR_POSITION[m[7].toLowerCase()];\n        } else if (m[8] !== undefined) {\n            center.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[8], m[9]);\n        }\n\n        if (m[10]) {\n            center.y = LENGTH_FOR_POSITION[m[10].toLowerCase()];\n        } else if (m[11] !== undefined) {\n            center.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[11], m[12]);\n        }\n    }\n\n    var gradientCenter = {\n        x: center.x === undefined ? bounds.width / 2 : center.x.getAbsoluteValue(bounds.width),\n        y: center.y === undefined ? bounds.height / 2 : center.y.getAbsoluteValue(bounds.height)\n    };\n    var gradientRadius = calculateRadius(m && m[2] || 'farthest-corner', shape, gradientCenter, radius, bounds);\n\n    return new RadialGradient(parseColorStops(args, m ? 1 : 0, Math.min(gradientRadius.x, gradientRadius.y)), shape, gradientCenter, gradientRadius);\n};\n\nvar calculateGradientDirection = function calculateGradientDirection(radian, bounds) {\n    var width = bounds.width;\n    var height = bounds.height;\n    var HALF_WIDTH = width * 0.5;\n    var HALF_HEIGHT = height * 0.5;\n    var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));\n    var HALF_LINE_LENGTH = lineLength / 2;\n\n    var x0 = HALF_WIDTH + Math.sin(radian) * HALF_LINE_LENGTH;\n    var y0 = HALF_HEIGHT - Math.cos(radian) * HALF_LINE_LENGTH;\n    var x1 = width - x0;\n    var y1 = height - y0;\n\n    return { x0: x0, x1: x1, y0: y0, y1: y1 };\n};\n\nvar parseTopRight = function parseTopRight(bounds) {\n    return Math.acos(bounds.width / 2 / ((0, _Util.distance)(bounds.width, bounds.height) / 2));\n};\n\nvar parseSideOrCorner = function parseSideOrCorner(side, bounds) {\n    switch (side) {\n        case 'bottom':\n        case 'to top':\n            return calculateGradientDirection(0, bounds);\n        case 'left':\n        case 'to right':\n            return calculateGradientDirection(Math.PI / 2, bounds);\n        case 'right':\n        case 'to left':\n            return calculateGradientDirection(3 * Math.PI / 2, bounds);\n        case 'top right':\n        case 'right top':\n        case 'to bottom left':\n        case 'to left bottom':\n            return calculateGradientDirection(Math.PI + parseTopRight(bounds), bounds);\n        case 'top left':\n        case 'left top':\n        case 'to bottom right':\n        case 'to right bottom':\n            return calculateGradientDirection(Math.PI - parseTopRight(bounds), bounds);\n        case 'bottom left':\n        case 'left bottom':\n        case 'to top right':\n        case 'to right top':\n            return calculateGradientDirection(parseTopRight(bounds), bounds);\n        case 'bottom right':\n        case 'right bottom':\n        case 'to top left':\n        case 'to left top':\n            return calculateGradientDirection(2 * Math.PI - parseTopRight(bounds), bounds);\n        case 'top':\n        case 'to bottom':\n        default:\n            return calculateGradientDirection(Math.PI, bounds);\n    }\n};\n\nvar parsePercentageAngle = function parsePercentageAngle(angle, bounds) {\n    var _angle$split$map = angle.split(' ').map(parseFloat),\n        _angle$split$map2 = _slicedToArray(_angle$split$map, 2),\n        left = _angle$split$map2[0],\n        top = _angle$split$map2[1];\n\n    var ratio = left / 100 * bounds.width / (top / 100 * bounds.height);\n\n    return calculateGradientDirection(Math.atan(isNaN(ratio) ? 1 : ratio) + Math.PI / 2, bounds);\n};\n\nvar findCorner = function findCorner(bounds, x, y, closest) {\n    var corners = [{ x: 0, y: 0 }, { x: 0, y: bounds.height }, { x: bounds.width, y: 0 }, { x: bounds.width, y: bounds.height }];\n\n    // $FlowFixMe\n    return corners.reduce(function (stat, corner) {\n        var d = (0, _Util.distance)(x - corner.x, y - corner.y);\n        if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {\n            return {\n                optimumCorner: corner,\n                optimumDistance: d\n            };\n        }\n\n        return stat;\n    }, {\n        optimumDistance: closest ? Infinity : -Infinity,\n        optimumCorner: null\n    }).optimumCorner;\n};\n\nvar calculateRadius = function calculateRadius(extent, shape, center, radius, bounds) {\n    var x = center.x;\n    var y = center.y;\n    var rx = 0;\n    var ry = 0;\n\n    switch (extent) {\n        case 'closest-side':\n            // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradientâs center.\n            // If the shape is an ellipse, it exactly meets the closest side in each dimension.\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n                rx = ry = Math.min(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n                rx = Math.min(Math.abs(x), Math.abs(x - bounds.width));\n                ry = Math.min(Math.abs(y), Math.abs(y - bounds.height));\n            }\n            break;\n\n        case 'closest-corner':\n            // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradientâs center.\n            // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n                rx = ry = Math.min((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n                // Compute the ratio ry/rx (which is to be the same as for \"closest-side\")\n                var c = Math.min(Math.abs(y), Math.abs(y - bounds.height)) / Math.min(Math.abs(x), Math.abs(x - bounds.width));\n                var corner = findCorner(bounds, x, y, true);\n                rx = (0, _Util.distance)(corner.x - x, (corner.y - y) / c);\n                ry = c * rx;\n            }\n            break;\n\n        case 'farthest-side':\n            // Same as closest-side, except the ending shape is sized based on the farthest side(s)\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n                rx = ry = Math.max(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n                rx = Math.max(Math.abs(x), Math.abs(x - bounds.width));\n                ry = Math.max(Math.abs(y), Math.abs(y - bounds.height));\n            }\n            break;\n\n        case 'farthest-corner':\n            // Same as closest-corner, except the ending shape is sized based on the farthest corner.\n            // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n                rx = ry = Math.max((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n                // Compute the ratio ry/rx (which is to be the same as for \"farthest-side\")\n                var _c = Math.max(Math.abs(y), Math.abs(y - bounds.height)) / Math.max(Math.abs(x), Math.abs(x - bounds.width));\n                var _corner = findCorner(bounds, x, y, false);\n                rx = (0, _Util.distance)(_corner.x - x, (_corner.y - y) / _c);\n                ry = _c * rx;\n            }\n            break;\n\n        default:\n            // pixel or percentage values\n            rx = radius.x || 0;\n            ry = radius.y !== undefined ? radius.y : rx;\n            break;\n    }\n\n    return {\n        x: rx,\n        y: ry\n    };\n};\n\nvar transformWebkitRadialGradientArgs = exports.transformWebkitRadialGradientArgs = function transformWebkitRadialGradientArgs(args) {\n    var shape = '';\n    var radius = '';\n    var extent = '';\n    var position = '';\n    var idx = 0;\n\n    var POSITION = /^(left|center|right|\\d+(?:px|r?em|%)?)(?:\\s+(top|center|bottom|\\d+(?:px|r?em|%)?))?$/i;\n    var SHAPE_AND_EXTENT = /^(circle|ellipse)?\\s*(closest-side|closest-corner|farthest-side|farthest-corner|contain|cover)?$/i;\n    var RADIUS = /^\\d+(px|r?em|%)?(?:\\s+\\d+(px|r?em|%)?)?$/i;\n\n    var matchStartPosition = args[idx].match(POSITION);\n    if (matchStartPosition) {\n        idx++;\n    }\n\n    var matchShapeExtent = args[idx].match(SHAPE_AND_EXTENT);\n    if (matchShapeExtent) {\n        shape = matchShapeExtent[1] || '';\n        extent = matchShapeExtent[2] || '';\n        if (extent === 'contain') {\n            extent = 'closest-side';\n        } else if (extent === 'cover') {\n            extent = 'farthest-corner';\n        }\n        idx++;\n    }\n\n    var matchStartRadius = args[idx].match(RADIUS);\n    if (matchStartRadius) {\n        idx++;\n    }\n\n    var matchEndPosition = args[idx].match(POSITION);\n    if (matchEndPosition) {\n        idx++;\n    }\n\n    var matchEndRadius = args[idx].match(RADIUS);\n    if (matchEndRadius) {\n        idx++;\n    }\n\n    var matchPosition = matchEndPosition || matchStartPosition;\n    if (matchPosition && matchPosition[1]) {\n        position = matchPosition[1] + (/^\\d+$/.test(matchPosition[1]) ? 'px' : '');\n        if (matchPosition[2]) {\n            position += ' ' + matchPosition[2] + (/^\\d+$/.test(matchPosition[2]) ? 'px' : '');\n        }\n    }\n\n    var matchRadius = matchEndRadius || matchStartRadius;\n    if (matchRadius) {\n        radius = matchRadius[0];\n        if (!matchRadius[1]) {\n            radius += 'px';\n        }\n    }\n\n    if (position && !shape && !radius && !extent) {\n        radius = position;\n        position = '';\n    }\n\n    if (position) {\n        position = 'at ' + position;\n    }\n\n    return [[shape, extent, radius, position].filter(function (s) {\n        return !!s;\n    }).join(' ')].concat(args.slice(idx));\n};\n\nvar transformObsoleteColorStops = function transformObsoleteColorStops(args) {\n    return args.map(function (color) {\n        return color.match(FROM_TO_COLORSTOP);\n    })\n    // $FlowFixMe\n    .map(function (v, index) {\n        if (!v) {\n            return args[index];\n        }\n\n        switch (v[1]) {\n            case 'from':\n                return v[4] + ' 0%';\n            case 'to':\n                return v[4] + ' 100%';\n            case 'color-stop':\n                if (v[3] === '%') {\n                    return v[4] + ' ' + v[2];\n                }\n                return v[4] + ' ' + parseFloat(v[2]) * 100 + '%';\n        }\n    });\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}